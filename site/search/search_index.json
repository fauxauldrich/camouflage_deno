{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Camouflage is a service virtualization tool inspired by namshi/mockserver . As the original description says, the mocking/service virtualization works on a file based structure where you simply organize your mocked HTTP responses in a bunch of mock files and it will serve them like they were coming from a real API; in this way you can write your frontends without caring too much whether your backend is really ready or not. Caution This Camouflage project is a Deno port of a Node project with the same name. Due to current limitations of Deno, there are some functionalities which are missing in Deno port (eg clustering, gRPC mocking, HTTP2 mocking). If you are okay with using Node JS for now, feel free to checkout the original project Camouflage for some really cool additional features. We'll be adding same features in this project as and when Deno allows. Why did we create Camouflage if a similar tool already exists? Well, the original tool has not been maintained for some time now. But more importantly, Camouflage simply borrows the idea from the original and though it does use some of the same logic and functions, majority of the code has been written from scratch. The underlying codebase has been re-written in Deno. Some features from the original tool might be missing, or have been implemented differently. (import and eval have not been ported to Camouflage) Camouflage introduces handlebars, which allows you to generate dynamic (more real) responses. Using handlebars, you can generate random numbers, string, alphanumeric string, UUIDs and random dates. You can also extract information from request queries, path, body or headers and use them in your response. You can use handlebars to carry out request matching for you. For example, return one response if a query param exists, return another if it doesn't. Camouflage currently supports 2 protocols, i.e. HTTP, HTTPs.","title":"Home"},{"location":"#home","text":"Camouflage is a service virtualization tool inspired by namshi/mockserver . As the original description says, the mocking/service virtualization works on a file based structure where you simply organize your mocked HTTP responses in a bunch of mock files and it will serve them like they were coming from a real API; in this way you can write your frontends without caring too much whether your backend is really ready or not. Caution This Camouflage project is a Deno port of a Node project with the same name. Due to current limitations of Deno, there are some functionalities which are missing in Deno port (eg clustering, gRPC mocking, HTTP2 mocking). If you are okay with using Node JS for now, feel free to checkout the original project Camouflage for some really cool additional features. We'll be adding same features in this project as and when Deno allows.","title":"Home"},{"location":"#why-did-we-create-camouflage-if-a-similar-tool-already-exists","text":"Well, the original tool has not been maintained for some time now. But more importantly, Camouflage simply borrows the idea from the original and though it does use some of the same logic and functions, majority of the code has been written from scratch. The underlying codebase has been re-written in Deno. Some features from the original tool might be missing, or have been implemented differently. (import and eval have not been ported to Camouflage) Camouflage introduces handlebars, which allows you to generate dynamic (more real) responses. Using handlebars, you can generate random numbers, string, alphanumeric string, UUIDs and random dates. You can also extract information from request queries, path, body or headers and use them in your response. You can use handlebars to carry out request matching for you. For example, return one response if a query param exists, return another if it doesn't. Camouflage currently supports 2 protocols, i.e. HTTP, HTTPs.","title":"Why did we create Camouflage if a similar tool already exists?"},{"location":"folder-structure/","text":"Folder Structure The way you organize your directories inside the ${MOCKS_DIR}, determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain. Basic GET Request to /hello-world Create a directory ${MOCKS_DIR}/hello-world Create a GET.mock file inside it with your required raw html response POST Request to /users Create a directory ${MOCKS_DIR}/users Create a POST.mock file inside it with your required raw html response GET Request to /users/:userId Create a directory ${MOCKS_DIR}/users/__ (double underscore) Create a GET.mock file inside it with your required raw html response Similarily you can create PUT.mock, DELETE.mock etc in your intended path. For wildcard, use directory name as __ (double underscore) Note Unlike original mockserver, request matching criteria, are taken care of inside the .mock files instead of naming the files in a certain way. We intend to keep the file names simple and in the format ${HTTP_METHOD}.mock Caution Protocols http, https and http2, share the same mocks directory and folder structure, however folder structure and mocks directory for gRPC mocks is different. Please refer to the section Mocking gRPC if you are planning to create gRPC mocks. What data to put in .mock files The data you want to put can be easily fetched using a curl command with -i -X flags in following manner. Example: curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ${MOCKS_DIR}/users/__, and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } }","title":"Folder Structure"},{"location":"folder-structure/#folder-structure","text":"The way you organize your directories inside the ${MOCKS_DIR}, determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain.","title":"Folder Structure"},{"location":"folder-structure/#basic-get-request-to-hello-world","text":"Create a directory ${MOCKS_DIR}/hello-world Create a GET.mock file inside it with your required raw html response","title":"Basic GET Request to /hello-world"},{"location":"folder-structure/#post-request-to-users","text":"Create a directory ${MOCKS_DIR}/users Create a POST.mock file inside it with your required raw html response","title":"POST Request to /users"},{"location":"folder-structure/#get-request-to-usersuserid","text":"Create a directory ${MOCKS_DIR}/users/__ (double underscore) Create a GET.mock file inside it with your required raw html response Similarily you can create PUT.mock, DELETE.mock etc in your intended path. For wildcard, use directory name as __ (double underscore) Note Unlike original mockserver, request matching criteria, are taken care of inside the .mock files instead of naming the files in a certain way. We intend to keep the file names simple and in the format ${HTTP_METHOD}.mock Caution Protocols http, https and http2, share the same mocks directory and folder structure, however folder structure and mocks directory for gRPC mocks is different. Please refer to the section Mocking gRPC if you are planning to create gRPC mocks.","title":"GET Request to /users/:userId"},{"location":"folder-structure/#what-data-to-put-in-mock-files","text":"The data you want to put can be easily fetched using a curl command with -i -X flags in following manner. Example: curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ${MOCKS_DIR}/users/__, and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } }","title":"What data to put in .mock files"},{"location":"getting-started/","text":"Getting Started Camouflage is a deno module, therefore to install Camouflage, you'd need to install Deno first, if you haven't already done so. You can then import Camouflage into your project: import { CamouflageConfig, CamouflageServer } from \"./mod.ts\"; Note that you'd also need to provide a config file to initialize Camouflage. import { YamlLoader } from \"https://deno.land/x/yaml_loader/mod.ts\"; const configLoader = new YamlLoader(); const config: CamouflageConfig = <CamouflageConfig>await configLoader.parseFile(\"./config.yaml\"); Create a config.yaml file at the root of your project. And paste the following content (update if required). Configuration Options / Sample Config yml File loglevel: INFO protocols: http: enable: true port: 8080 mocks: \"./mocks\" https: enable: true port: 8443 cert: \"./certs/server.crt\" key: \"./certs/server.key\" For simplicity, create an inputs array to store the configs in following order. const inputs = [ config.loglevel, config.protocols.http.enable, config.protocols.http.port, config.protocols.http.mocks, config.protocols.https.enable, config.protocols.https.port, config.protocols.https.cert, config.protocols.https.key, ]; Finally, create an instance of CamouflageServer and call start() by spreading the inputs array as it's parameters const camouflageServer: CamouflageServer = new CamouflageServer(); // @ts-ignore ignore camouflageServer.start(...inputs); Create your first mock Camouflage follows the same convention as mockserver to create mocks. For example, Note All further references to the variable ${MOCK_DIR} in this documentation will refer to the directory you have specified in your config.yaml file under config.protocols.http.mocks You start by creating a directory ${MOCKS_DIR}/hello-world Create a file GET.mock under ${MOCKS_DIR}/hello-world. Paste following content: HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } Navigate to http://localhost:8080/hello-world","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Camouflage is a deno module, therefore to install Camouflage, you'd need to install Deno first, if you haven't already done so. You can then import Camouflage into your project: import { CamouflageConfig, CamouflageServer } from \"./mod.ts\"; Note that you'd also need to provide a config file to initialize Camouflage. import { YamlLoader } from \"https://deno.land/x/yaml_loader/mod.ts\"; const configLoader = new YamlLoader(); const config: CamouflageConfig = <CamouflageConfig>await configLoader.parseFile(\"./config.yaml\"); Create a config.yaml file at the root of your project. And paste the following content (update if required).","title":"Getting Started"},{"location":"getting-started/#configuration-options-sample-config-yml-file","text":"loglevel: INFO protocols: http: enable: true port: 8080 mocks: \"./mocks\" https: enable: true port: 8443 cert: \"./certs/server.crt\" key: \"./certs/server.key\" For simplicity, create an inputs array to store the configs in following order. const inputs = [ config.loglevel, config.protocols.http.enable, config.protocols.http.port, config.protocols.http.mocks, config.protocols.https.enable, config.protocols.https.port, config.protocols.https.cert, config.protocols.https.key, ]; Finally, create an instance of CamouflageServer and call start() by spreading the inputs array as it's parameters const camouflageServer: CamouflageServer = new CamouflageServer(); // @ts-ignore ignore camouflageServer.start(...inputs);","title":"Configuration Options / Sample Config yml File"},{"location":"getting-started/#create-your-first-mock","text":"Camouflage follows the same convention as mockserver to create mocks. For example, Note All further references to the variable ${MOCK_DIR} in this documentation will refer to the directory you have specified in your config.yaml file under config.protocols.http.mocks You start by creating a directory ${MOCKS_DIR}/hello-world Create a file GET.mock under ${MOCKS_DIR}/hello-world. Paste following content: HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } Navigate to http://localhost:8080/hello-world","title":"Create your first mock"},{"location":"handlebars/","text":"Handlebars Handlebars help you add character to your response. Instead of sending a static response or writing some code to generate a dynamic response, you can now simply use handlebars and let Camouflage do the work for you. Custom Helpers randomValue Type: Custom Helper Usage: {{randomValue}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{randomValue type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{randomValue type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{randomValue type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string. now Type: Custom Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? Use any format you'd like as long as it is supported by momentjs. {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset specify the delta for your desired date from current date. Units for specifying offset are Key Shorthand years y quarters q months M weeks w days d hours h minutes m seconds s milliseconds ms capture Type: Custom Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if say your endpoint looks like /hello-world?firstName=John&lastName=Wick. And your response is {\"message\": \"Hello Wick, John\"}, you can make the response dynamic by formatting your response as { \"message\": \"{{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='path' regex='\\/users\\/get\\/(.*)?'}} - For path, you'd need to specify a regex to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from request body, your options are either using='regex' or using='jsonpath'. Selector will change accordingly. num_between Type: Custom Helper Usage: {{num_between lower=500 upper=600}} : Generate a number between two values. Example: you can add this value in your response header with a key Response-Delay, to simulate a latency in your API. Not providing lower/upper value or providing values where lower > upper would set delay to 0, i.e. won't have any effect. Check Response Delays page for a detailed example Inbuilt Helpers Note A variety of helpers are made available by Handlebar.js itself and Camouflage team had nothing to do with those, and we don't take credit for it. Following example just showcases how the inbuilt helpers can be used with Camouflage, more details and examples can be found just about anywhere on the internet. As far as inbuilt helpers are concerned, you can use any of them as long as it makes sense to you. Raw HTML Request: POST /users HTTP/1.1 Content-Type: application/json { \"firstName\": \"Robert\", \"lastName\": \"Downey\", \"nicknames\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } Expected Raw HTML Response: HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91\", \"data\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } To create this service in camouflage, create a directory users under your ${MOCKS_DIR}. i.e. ${MOCKS_DIR}/users Create a file POST.mock and add following content to the file HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: {{randomValue type='UUID'}}\", \"data\": [ {{#each request_body.nicknames}} {{#if @last}} { \"nickname\": \"{{this.nickname}}\" } {{else}} { \"nickname\": \"{{this.nickname}}\" }, {{/if}} {{/each}} ] } Explanation We replaced the static UUID f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91 with {{randomValue type='UUID'}} , so that this value updates on each request. We wrapped our JSONObject inside data array with an each helper which iterates over nicknames array from request body. Finally we put an if condition to check if we are at the last element of the array, we shouldn't append a comma at the end of our JSONObject, in order to get a valid JSON. If we are at any other element in the array, we'll add a comma to JSONObject. Available inbuilt helpers are if , unless , each , with , lookup and log . More details are available at Handlebars Documentation","title":"Handlebars"},{"location":"handlebars/#handlebars","text":"Handlebars help you add character to your response. Instead of sending a static response or writing some code to generate a dynamic response, you can now simply use handlebars and let Camouflage do the work for you.","title":"Handlebars"},{"location":"handlebars/#custom-helpers","text":"","title":"Custom Helpers"},{"location":"handlebars/#randomvalue","text":"Type: Custom Helper Usage: {{randomValue}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{randomValue type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{randomValue type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{randomValue type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string.","title":"randomValue"},{"location":"handlebars/#now","text":"Type: Custom Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? Use any format you'd like as long as it is supported by momentjs. {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset specify the delta for your desired date from current date. Units for specifying offset are Key Shorthand years y quarters q months M weeks w days d hours h minutes m seconds s milliseconds ms","title":"now"},{"location":"handlebars/#capture","text":"Type: Custom Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if say your endpoint looks like /hello-world?firstName=John&lastName=Wick. And your response is {\"message\": \"Hello Wick, John\"}, you can make the response dynamic by formatting your response as { \"message\": \"{{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='path' regex='\\/users\\/get\\/(.*)?'}} - For path, you'd need to specify a regex to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from request body, your options are either using='regex' or using='jsonpath'. Selector will change accordingly.","title":"capture"},{"location":"handlebars/#num_between","text":"Type: Custom Helper Usage: {{num_between lower=500 upper=600}} : Generate a number between two values. Example: you can add this value in your response header with a key Response-Delay, to simulate a latency in your API. Not providing lower/upper value or providing values where lower > upper would set delay to 0, i.e. won't have any effect. Check Response Delays page for a detailed example","title":"num_between"},{"location":"handlebars/#inbuilt-helpers","text":"Note A variety of helpers are made available by Handlebar.js itself and Camouflage team had nothing to do with those, and we don't take credit for it. Following example just showcases how the inbuilt helpers can be used with Camouflage, more details and examples can be found just about anywhere on the internet. As far as inbuilt helpers are concerned, you can use any of them as long as it makes sense to you. Raw HTML Request: POST /users HTTP/1.1 Content-Type: application/json { \"firstName\": \"Robert\", \"lastName\": \"Downey\", \"nicknames\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } Expected Raw HTML Response: HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91\", \"data\": [ { \"nickname\": \"Bob\" }, { \"nickname\": \"Rob\" } ] } To create this service in camouflage, create a directory users under your ${MOCKS_DIR}. i.e. ${MOCKS_DIR}/users Create a file POST.mock and add following content to the file HTTP/1.1 201 OK X-Requested-By: user-service Content-Type: application/json { \"status\": 201, \"message\": \"User created with ID: {{randomValue type='UUID'}}\", \"data\": [ {{#each request_body.nicknames}} {{#if @last}} { \"nickname\": \"{{this.nickname}}\" } {{else}} { \"nickname\": \"{{this.nickname}}\" }, {{/if}} {{/each}} ] } Explanation We replaced the static UUID f45a3d2d-8dfb-4fc6-a0b2-c94882cd5b91 with {{randomValue type='UUID'}} , so that this value updates on each request. We wrapped our JSONObject inside data array with an each helper which iterates over nicknames array from request body. Finally we put an if condition to check if we are at the last element of the array, we shouldn't append a comma at the end of our JSONObject, in order to get a valid JSON. If we are at any other element in the array, we'll add a comma to JSONObject. Available inbuilt helpers are if , unless , each , with , lookup and log . More details are available at Handlebars Documentation","title":"Inbuilt Helpers"},{"location":"request-matching/","text":"Request Matching There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized resposne. To do so you can utilize the power of handlebars again. Simply provide an if else condition and you are good to go. Consider following example. You expect the user to call the endpoint /hello-world in two ways. 1) By simple making a GET request to /hello-world.; Or 2) By adding a query parameter name in the GET request to /hello-world. i.e. /hello-world?name=John Based on how the user calls the API, you'd want to send a different response. This can be done in following manner: Create GET.mock file under the directory ${MOCKS_DIR}/hello-world. And paste following content: {{#if request.query.name}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}} Explanation We are going to check if a query parameter with the key 'name' exists in the incoming request. We do so by adding an if condition {{#if request.query.name}} You can also check if that parameter equals a certain value {{#if request.query.name='John'}} Rest of the code is self explanatory, where if the condition is true, i.e. incoming request has a query parameter with key name , the greeting field in our response object would be Hello John , else the greeting would be Hello World . Thus if the end user makes a GET request as /hello-world?name=John , he'd get a greeting Hello John . However, if the user calls /hello-world without any name , he'd get a greeting as Hello World","title":"Request matching"},{"location":"request-matching/#request-matching","text":"There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized resposne. To do so you can utilize the power of handlebars again. Simply provide an if else condition and you are good to go. Consider following example. You expect the user to call the endpoint /hello-world in two ways. 1) By simple making a GET request to /hello-world.; Or 2) By adding a query parameter name in the GET request to /hello-world. i.e. /hello-world?name=John Based on how the user calls the API, you'd want to send a different response. This can be done in following manner: Create GET.mock file under the directory ${MOCKS_DIR}/hello-world. And paste following content: {{#if request.query.name}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}}","title":"Request Matching"},{"location":"request-matching/#explanation","text":"We are going to check if a query parameter with the key 'name' exists in the incoming request. We do so by adding an if condition {{#if request.query.name}} You can also check if that parameter equals a certain value {{#if request.query.name='John'}} Rest of the code is self explanatory, where if the condition is true, i.e. incoming request has a query parameter with key name , the greeting field in our response object would be Hello John , else the greeting would be Hello World . Thus if the end user makes a GET request as /hello-world?name=John , he'd get a greeting Hello John . However, if the user calls /hello-world without any name , he'd get a greeting as Hello World","title":"Explanation"},{"location":"request-model/","text":"Request model Request object made available by camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.method request.originalUrl request.path request.protocol request.query request.headers request_body Note We'd like to highlight request_body (request underscore body) specially, as we understand it might be an area of confusion. This will be fixed in future releases to standard request.body.","title":"Request model"},{"location":"request-model/#request-model","text":"Request object made available by camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.method request.originalUrl request.path request.protocol request.query request.headers request_body Note We'd like to highlight request_body (request underscore body) specially, as we understand it might be an area of confusion. This will be fixed in future releases to standard request.body.","title":"Request model"},{"location":"response-delays/","text":"Response Delay Response delays are handled in a similar manner as it was done in mockserver, i.e. you add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for /hello-world endpoint, contents of your .mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} This would add a random delay of a value between 500 to 600 milliseconds","title":"Response delays"},{"location":"response-delays/#response-delay","text":"Response delays are handled in a similar manner as it was done in mockserver, i.e. you add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for /hello-world endpoint, contents of your .mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} This would add a random delay of a value between 500 to 600 milliseconds","title":"Response Delay"}]}